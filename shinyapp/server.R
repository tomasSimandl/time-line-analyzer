library(shiny)
library(anytime)
library(data.table)
library(plotly)
library(shinyjs)
library(XML)

# =================================================================================================================================
# ==================================================== DATA READING AND EDITING ===================================================
# =================================================================================================================================

# Check input values and decide which function will be used for loading a file. After success file load call function for data
# sampling.
load_data <- function(file, deviceSelect, startTime, endTime, timeInterval, timeShift){
   if(is.null(file) || is.null(startTime) || is.null(endTime) || !is.numeric(timeInterval) || !is.numeric(timeShift)) return(NULL)
   
   data <- switch(deviceSelect,
                  chest_strap = load_chest_strap_csv(file, timeShift),
                  garmin = load_garmin_tcx(file, timeShift),
                  basis = load_basis_csv(file, timeShift),
                  fitbit = load_fitbit_csv(file, timeShift),
                  return(NULL))
   
   data_sampling(data, get_time(startTime), get_time(endTime), timeInterval)
}

# Load file in tcx format. Verify loaded data and return data.table with columns 'time' and 'bpm'.
load_garmin_tcx <- function(file, timeShift){
   soubor <- xmlParse(file)
   
   data <- xmlToDataFrame(getNodeSet(soubor, "//ns:Trackpoint", "ns"))
   time_vector <- as.numeric(format(strptime(x = data$Time, format = "%Y-%m-%dT%H:%M:%S"), format = "%s"))  + timeShift
   bpm_vector <- as.numeric(as.character(data$HeartRateBpm))
   
   if(length(time_vector[is.na(time_vector)]) + length(bpm_vector[is.na(bpm_vector)]) != 0){
      return(NULL)
   }
   data.table(time = time_vector, bpm = bpm_vector)
}

# Load file in csv format created in Basis Peak watches. Verify loaded data and return data.table with columns 'time' and 'bpm'.
load_basis_csv <- function(file, timeShift){
   columnsNames <- c("", "time", "", "", "bpm", "", "")
   
   data <- read.csv(file, col.names = columnsNames, header = TRUE)
   if(length(data$bpm[!is.numeric(data$bpm)]) != 0){
      return(NULL)
   }
   data.table(time = as.numeric(format(as.POSIXct(data$time), format = "%s")) + timeShift, bpm = data$bpm)
}

# Load file in csv format where columns are 'date', 'time' and 'bpm' divided by comma. Verify loaded data and return data.table
# with columns 'time' and 'bpm'.
load_fitbit_csv <- function(file, timeShift){
   columnsNames <- c("date", "time", "bpm")
   
   data <- read.csv(file, col.names = columnsNames, header = FALSE)
   if(length(data$bpm[!is.numeric(data$bpm)]) != 0){
      return(NULL)
   }
   
   data.table(time = as.numeric(format(as.POSIXct(paste(data$date, data$time, sep = " ")), format = "%s")) + timeShift, bpm = data$bpm)
}

# Load file in csv format where are nine columns divided by comma. First column is 'time' and third column is 'bpm'. Verify loaded
# data and return data.table with two columns 'time' and 'bpm'.
load_chest_strap_csv <- function(file, timeShift) {
   columnsNames <- c("time", "", "bpm", "", "", "", "", "", "")
   
   data <- read.csv(file, col.names = columnsNames, header = FALSE)
   
   if(length(data$bpm[!is.numeric(data$bpm)]) + length(data$time[!is.numeric(data$time)]) != 0){
      return(NULL)
   }
   
   data_by_sec <- data.table(time = floor(data$time/1000) + timeShift, bpm = data$bpm)[, mean(bpm), by=time]
   setnames(data_by_sec, c("time", "V1"), c("time", "bpm"))
   data_by_sec
}

# Samples input data. Return data.table with time from startTime to endTime with spacing timeInterval. Sampling is create by averaging.
data_sampling <- function(data, startTime, endTime, timeInterval){
   if(is.null(data) || nrow(data) == 0) return(NULL)
   
   sequence <- seq(startTime, endTime, timeInterval)
   size <- length(sequence)
   DT <- data.table(time = sequence, bpm = numeric(size))
   
   for (n in 1:nrow(DT)){
      frame <- data[time <= startTime]
      frame <- frame[time > startTime - timeInterval]
      data_mean <- mean(frame$bpm)
      if(!is.na(data_mean)){
         set(DT, n, "bpm", data_mean)
      }
      startTime <- startTime + timeInterval
   }
   DT
}

# Filter data based on options value.
# If option contains izv, delete all values where is zero. 
# If option contains io, delete all value which are outliers.
filter_data <- function(data, options, outliers = TRUE){
   if(is.null(data)) return(NULL)
   if(is.null(options)) return(data)
   
   ignoreZeroValues  <- 'izv' %in% options
   ignoreOutliers    <- 'io'  %in% options
   
   if (ignoreZeroValues) {
      data <- data[apply(data[,.(time, bpm.x, bpm.y)], 1, function(row) all(row != 0)),]
   }
   
   if (ignoreOutliers && outliers) {
      data <- data[!data$residues %in% boxplot.stats(data$residues)$out]
   }
   data
}

# =================================================================================================================================
# ========================================================== CALCULATION ==========================================================
# =================================================================================================================================

calculate_calculation <- function(time_lines){
   if(is.null(time_lines)) return(NULL)
   
   dispersion <- calculate_dispersion(time_lines$residues)
   std_dev <- sqrt(dispersion)
   corelation <- cor(x = time_lines$bpm.x, y = time_lines$bpm.y, method = c("pearson"))
   
   data.table(
      c("Dispersion", "Standard deviation", "Corelation", "Error SD"),
      c(dispersion, std_dev, corelation, sd(time_lines$residues))
   )
}

calculate_dispersion <- function(residues){
   if(is.null(residues)) return(NULL)
   
   sum(residues ^ 2)/length(residues)
}

calculate_quantile <- function(time_lines, name1, name2){
   if(is.null(time_lines)) return(NULL)
   
   tm1 <- time_lines$bpm.x
   tm2 <- time_lines$bpm.y
   tm3 <- time_lines$residues
   tm4 <- abs(time_lines$residues)
   tm5 <- (time_lines$residues / time_lines$bpm.x) * 100
   tm6 <- abs(time_lines$residues / time_lines$bpm.x) * 100
   
   tm5[is.nan(tm5)] <- 0
   tm6[is.nan(tm6)] <- 0
   
   table <- data.table(
      c("Min", "1st Qu.", "Mean", "Median", "3rd Qu.", "Max"),
      calculate_quantile_mean(tm1),
      calculate_quantile_mean(tm2),
      calculate_quantile_mean(tm3),
      calculate_quantile_mean(tm4),
      calculate_quantile_mean(tm5),
      calculate_quantile_mean(tm6)
   )
   
   setnames(table, c("V1","V2","V3","V4","V5", "V6", "V7"),
            c(
               "",
               paste0(name1, " [BPM]"),
               paste0(name2, " [BPM]"),
               'error [BPM]',
               'absolute error [BPM]',
               'relative error [%]',
               'absolute relative error [%]'
               )
            )
   table
}

calculate_quantile_mean <- function(time_line){
   quantile <- quantile(time_line)
   mean <- mean(time_line)
   
   c(quantile[1:2], mean, quantile[3:5])
}

get_time <- function(strTime) {
   as.numeric(format(strptime(x = strTime, format = "%d.%m.%Y %H:%M:%S"), format = "%s"))
}

# =================================================================================================================================
# =========================================================== VALIDATION ==========================================================
# =================================================================================================================================

# If inputElement is null, then element with inputId is assigned to color_red class and TRUE is returned. Otherwise fail is returned.
checkInput <- function(inputElement, inputId, fail){
   if(is.null(inputElement)){
      shinyjs::addClass(id = inputId, class = "color_red")
      return(TRUE)
   }
   return(fail)
}

# If inputElement is non numeric or out of range(minValue, maxValue), element with inputId is assigned to color_red class and
# error message is returned. Otherwise empty string is returned. 
checkNumericInput <- function(inputElement, inputId, inputName, minValue, maxValue){
   message <- ""
   if(!is.numeric(inputElement)) {
      message <- paste("- Element", inputName, "contains non numeric value.")
   } else if(inputElement > maxValue || inputElement < minValue){
      message <- paste("- Value of element", inputName, "is out of range. Expected: <", minValue, ",", maxValue ,">")
   }
   if(message != ""){
      shinyjs::addClass(id = inputId, class = "color_red")
   }
   return(message)
}

# If inputStartElement is NULL or value can not be parse, element with inputStartId is assigned to color_red class and error 
# message is returned. Same behavior is on inputEndElement and inputEndId. If inputStartElement have bigger value than 
# inputEnd element, elements with inputStartId and inputEndId are assigned to color_red class and error message is returned.
# Otherwise return empty string.
checkTimeInput <- function(inputStartElement, inputEndElement, inputStartId, inputEndId, inputsName){
   fail <- FALSE
   fail <- checkInput(inputStartElement, inputStartId, fail)
   fail <- checkInput(inputEndElement, inputEndId, fail)
   if(fail){
      return(paste("- Please fill", inputsName))
   }
   
   startTime <- get_time(inputStartElement)
   endTime <- get_time(inputEndElement)
   
   if(is.na(startTime)){
      shinyjs::addClass(id = inputStartId, class = "color_red")
      fail <- TRUE
   }
   if(is.na(endTime)){
      shinyjs::addClass(id = inputEndId, class = "color_red")
      fail <- TRUE
   }
   if(fail){
      return(paste("-", inputsName, "have incorrect format. Expected: dd.mm.yyyy HH:MM:SS"))
   }
   
   if(startTime > endTime){
      shinyjs::addClass(id = inputStartId, class = "color_red")
      shinyjs::addClass(id = inputEndId, class = "color_red")
      return(paste("-", inputsName, "is incorrect. First value is bigger then second."))
   }
   return("")
}

# If input parametr is TRUE or missing, all tabs in navbar are shown. Othrewise hide tabs: LOW, MEDIUM, HIGH, SUMMARY and TABLES.
toggleTabs <- function(show = TRUE){
   if(show){
      shinyjs::show(selector = "#navbar *", anim = TRUE)
   } else {
      shinyjs::hide(selector = "#navbar li a[data-value=tabLow]")
      shinyjs::hide(selector = "#navbar li a[data-value=tabMedium]")
      shinyjs::hide(selector = "#navbar li a[data-value=tabHigh]")
      shinyjs::hide(selector = "#navbar li a[data-value=tabSummary]")
      shinyjs::hide(selector = "#navbar li a[data-value=tabTables]")
   }
}

# Concate input messages with new line as separator. If one of messages is empty, return only second message. If both messages
# are empty, return empty message.
paste1 <- function(message1, message2){
   if (message1 != "" && message2 != ""){
      return(paste(message1, message2, sep = "\n"))
   } else{
      if (message1 != ""){
         return(message1)
      } else {
         return(message2)
      }
   }
}

# =================================================================================================================================
# ======================================================= GRAPHS AND TABLES =======================================================
# =================================================================================================================================

# Create plot with two lines.
create_plot <- function(time_lines, name1, name2){
   validate(
      need(!is.null(time_lines),'Can not create a plot. No input data.'),
      need(nrow(time_lines) != 0,'Can not create a plot. No input data.')
   )
   
   plot_ly(y = time_lines$bpm.x, x = anytime(time_lines$time), name = name1, type = 'scatter', mode = 'lines')%>%
      add_trace(y = time_lines$bpm.y, name = name2, mode = 'lines')%>%
      layout(xaxis = list(title = "Time"), yaxis = list(title = "BPM"))
}

# Create plot of residuas.
create_resi_plot <- function(time_lines){
   validate(
      need(!is.null(time_lines),'Can not create a plot. No input data.'),
      need(nrow(time_lines) != 0,'Can not create a plot. No input data.')
   )
   
   plot_ly(time_lines, y = ~residues, x = anytime(time_lines$time), type = 'scatter', mode = 'lines')%>%
      layout(xaxis = list(title = "Time"), yaxis = list(title = "A - B [BPM]"))
}

# Create Bland&Altman plot from input data.
create_bland_altman_plot <- function(time_lines){
   validate(
      need(!is.null(time_lines),'Can not create Bland-Altman plot. No input data.'),
      need(nrow(time_lines) != 0,'Can not create Bland-Altman plot. No input data.')
   )
   
   data.sd <- 1.96 * sd(time_lines$residues)
   data.mean <- mean(time_lines$residues)
   data.x <- (time_lines$bpm.x + time_lines$bpm.y)/2
   data.y <- time_lines$bpm.x - time_lines$bpm.y
   
   plot_ly(x = ~data.x, y = ~data.y, name = 'data', type = 'scatter', mode = 'markers') %>%
      add_trace(y = ~data.mean + data.sd, name = 'Mean + 1.96SD', mode = 'lines') %>%
      add_trace(y = ~data.mean, name = 'Mean', mode = 'lines') %>%
      add_trace(y = ~data.mean - data.sd, name = 'Mean - 1.96SD', mode = 'lines') %>%
      layout(xaxis = list(zeroline = FALSE, title = '(A + B)/2'), yaxis = list(zeroline = FALSE, title = 'A - B'))
}

# Create box plot showing outliers.
create_box_plot <- function(time_lines){
   plot_ly(y = ~time_lines$residues, type = "box", name = '') %>%
      layout(xaxis = list(title = "", showticklabels = FALSE, zeroline = FALSE), yaxis = list(title = "A - B [BPM]", zeroline = FALSE))
}

# Create table with time, bpm value form first device, bpm value from second device and bpm resiues.
create_table <- function(data, device1, device2){
   if(is.null(data) || nrow(data)) return(NULL)
   
   table <- data.table(format(anytime(data$time), format = "%d.%m.%Y %H:%M:%S"), data$bpm.x, data$bpm.y, data$residues)
   setnames(table, c("V1", "V2", "V3", "V4"), c("Time", paste0(device1, " [BPM]"), paste0(device2, " [BPM]"), "Residuas [BPM]"))
   table
}

# =================================================================================================================================
# ============================================================ SERVER =============================================================
# =================================================================================================================================
function(input, output, session) {
   print("--------------------------------------------- start --------------------------------------------------------")
   
   toggleTabs(FALSE) # hide tabs
   
   # ======================================================== OBSERVATION =========================================================
   
   # On click on submitBtn input data are validated. On success summary tab is displayed. Otherwise alert is shown.
   observeEvent(input$submitBtn, {
      shinyjs::removeClass(selector = ".divs", class = "color_red")
      
      shinyjs::html(id = "submitBtn", html = "<img src=\"loading.svg\" style=\"width: 20px;\">")
      
      message <- ""
      fail <- FALSE
      
      fail <- checkInput(input$inFileLow1, "divInputLow1", fail)
      fail <- checkInput(input$inFileLow2, "divInputLow2", fail)
      fail <- checkInput(input$inFileMed1, "divInputMed1", fail)
      fail <- checkInput(input$inFileMed2, "divInputMed2", fail)
      fail <- checkInput(input$inFileHig1, "divInputHig1", fail)
      fail <- checkInput(input$inFileHig2, "divInputHig2", fail)
      if(fail){
         message <- "- Please fill empty inputs!"
      }
      message <- paste1(message, checkNumericInput(input$timeZone1, "divTimeZone1", success, -12, 14))
      message <- paste1(message, checkNumericInput(input$timeZone2, "divTimeZone2", success, -12, 14))
      message <- paste1(message, checkNumericInput(input$timeShiftLow, "divTimeShiftLow", "Time Shift Low", -3600, 3600))
      message <- paste1(message, checkNumericInput(input$timeShiftMed, "divTimeShiftMed", "Time Shift Medium", -3600, 3600))
      message <- paste1(message, checkNumericInput(input$timeShiftHig, "divTimeShiftHig", "Time Shift High", -3600, 3600))
      message <- paste1(message, checkNumericInput(input$timeIntervalInput, "divTimeIntervalInput", "Time Sampling Interval", 1, 60))
      message <- paste1(message, checkTimeInput(input$startMeasLow, input$endMeasLow, "divStartMeasLow", "divEndMeasLow", "Measurement interval for low load"))
      message <- paste1(message, checkTimeInput(input$startMeasMed, input$endMeasMed, "divStartMeasMed", "divEndMeasMed", "Measurement interval for medium load"))
      message <- paste1(message, checkTimeInput(input$startMeasHig, input$endMeasHig, "divStartMeasHig", "divEndMeasHig", "Measurement interval for high load"))
      
      if(is.null(filteredInputLow()) || nrow(filteredInputLow()) == 0) {
         message <- paste(message, "- Input data are incorrect. Can not make the calculations for low load", sep = "\n")
      }
      if(is.null(filteredInputMed()) || nrow(filteredInputMed()) == 0) {
         message <- paste(message, "- Input data are incorrect. Can not make the calculations for medium load", sep = "\n")
      }
      if(is.null(filteredInputHig()) || nrow(filteredInputHig()) == 0) {
         message <- paste(message, "- Input data are incorrect. Can not make the calculations for high load", sep = "\n")
      }
      
      shinyjs::html(id = "submitBtn", html = "Submit")
      if(message == ""){
         toggleTabs()
         updateNavbarPage(session, "navbar", selected = "tabSummary")
      } else {
         toggleTabs(FALSE)
         session$sendCustomMessage(type = 'allertMessage', message = message)
      }
   })
   
   # When value is changed of some element in list below, tabs with results are hiden.
   observeEvent({
      input$inFileLow1
      input$inFileLow2
      input$inFileMed1
      input$inFileMed2
      input$inFileHig1
      input$inFileLow2
      input$deviceSelect1
      input$deviceSelect2
      input$timeZone1
      input$timeZone2
      input$timeIntervalInput
      input$startMeasLow
      input$endMeasLow
      input$startMeasMed
      input$endMeasMed
      input$startMeasHig
      input$endMeasHig
      input$timeShiftLow
      input$timeShiftMed
      input$timeShiftHig
   }, {
      toggleTabs(FALSE)
   })
   
   # ===================================================== DATA MANIPULATION ======================================================
   
   # load files on inputs change
   inputLow1 <- reactive({
      data <- load_data(file = input$inFileLow1$datapath, deviceSelect = input$deviceSelect1, input$startMeasLow, input$endMeasLow, input$timeIntervalInput,  input$timeZone1*3600)
      if(is.null(data) || nrow(data) == 0) return(NULL)
      data
   })
   inputMed1 <- reactive({
      data <- load_data(file = input$inFileMed1$datapath, deviceSelect = input$deviceSelect1, input$startMeasMed, input$endMeasMed, input$timeIntervalInput,  input$timeZone1*3600)
      if(is.null(data) || nrow(data) == 0) return(NULL)
      data
   })
   inputHig1 <- reactive({
      data <- load_data(file = input$inFileHig1$datapath, deviceSelect = input$deviceSelect1, input$startMeasHig, input$endMeasHig, input$timeIntervalInput,  input$timeZone1*3600)
      if(is.null(data) || nrow(data) == 0) return(NULL)
      data
   })
   inputLow2 <- reactive({
      data <- load_data(file = input$inFileLow2$datapath, deviceSelect = input$deviceSelect2, input$startMeasLow, input$endMeasLow, input$timeIntervalInput, input$timeShiftLow + (input$timeZone2*3600))
      if(is.null(data) || nrow(data) == 0) return(NULL)
      data
   })
   inputMed2 <- reactive({
      data <- load_data(file = input$inFileMed2$datapath, deviceSelect = input$deviceSelect2, input$startMeasMed, input$endMeasMed, input$timeIntervalInput, input$timeShiftMed + (input$timeZone2*3600))
      if(is.null(data) || nrow(data) == 0) return(NULL)
      data
   })
   inputHig2 <- reactive({
      data <- load_data(file = input$inFileHig2$datapath, deviceSelect = input$deviceSelect2, input$startMeasHig, input$endMeasHig, input$timeIntervalInput, input$timeShiftHig + (input$timeZone2*3600))
      if(is.null(data) || nrow(data) == 0) return(NULL)
      data
   })
   
   # merge data of same measurement from two devices and filter with outliers disabled
   inputLowOutliers <- reactive({
      tryResult <- try({
         time_line1 <- inputLow1()
         time_line2 <- inputLow2()
      }, silent = TRUE)
      if("try-error" %in% class(tryResult)) return(NULL)
      if(is.null(time_line1) || is.null(time_line2)) return(NULL)
      
      
      data <- merge(x = time_line1, y = time_line2, by = "time")
      data <- filter_data(data[, residues := (data$bpm.x - data$bpm.y)], options = input$otherOptions, outliers = FALSE)
      if(is.null(data) || nrow(data) == 0) return(NULL)
      data
   })
   inputMedOutliers <- reactive({
      tryResult <- try({
         time_line1 <- inputMed1()
         time_line2 <- inputMed2()
      }, silent = TRUE)
      if("try-error" %in% class(tryResult)) return(NULL)
      if(is.null(time_line1) || is.null(time_line2)) return(NULL)
      
      data <- merge(x = time_line1, y = time_line2, by = "time")
      data <- filter_data(data[, residues := (data$bpm.x - data$bpm.y)], options = input$otherOptions, outliers = FALSE)
      if(is.null(data) || nrow(data) == 0) return(NULL)
      data
   })
   inputHigOutliers <- reactive({
      tryResult <- try({
         time_line1 <- inputHig1()
         time_line2 <- inputHig2()
      }, silent = FALSE)
      if("try-error" %in% class(tryResult)) return(NULL)
      if(is.null(time_line1) || is.null(time_line2)) return(NULL)
      
      data <- merge(x = time_line1, y = time_line2, by = "time")
      data <- filter_data(data[, residues := (data$bpm.x - data$bpm.y)], options = input$otherOptions, outliers = FALSE)
      if(is.null(data) || nrow(data) == 0) return(NULL)
      data
   })
   inputSummaryOutliers <- reactive({
      rbind(inputLowOutliers(), inputMedOutliers(), inputHigOutliers())
   })
   
   # filter data from input*Outliers based on input$otherOptions
   filteredInputLow <- reactive({
      data <- filter_data(inputLowOutliers(), input$otherOptions)
      if(is.null(data) || nrow(data) == 0) return(NULL)
      data
   })
   filteredInputMed <- reactive({
      data <- filter_data(inputMedOutliers(), input$otherOptions)
      if(is.null(data) || nrow(data) == 0) return(NULL)
      data
   })
   filteredInputHig <- reactive({
      data <- filter_data(inputHigOutliers(), input$otherOptions)
      if(is.null(data) || nrow(data) == 0) return(NULL)
      data
   })
   filteredInputSummary <- reactive({
      data <- filter_data(inputSummaryOutliers(), input$otherOptions) 
      if(is.null(data) || nrow(data) == 0) return(NULL)
      data
   })
   
   # ======================================================= DATA RENDERING =======================================================
   
   # render table of basic calculatinos(corelation, standard deviation,...)
   output$calculationLow <-renderTable(colnames = FALSE,{
      data <- calculate_calculation(filteredInputLow())
      req(data)
      data
   })
   output$calculationMed <-renderTable(colnames = FALSE,{
      data <- calculate_calculation(filteredInputMed())
      req(data)
      data
   })
   output$calculationHig <-renderTable(colnames = FALSE,{
      data <- calculate_calculation(filteredInputHig())
      req(data)
      data
   })
   output$calculationSum <-renderTable(colnames = FALSE,{
      data <- calculate_calculation(filteredInputSummary())
      req(data)
      data
   })
   
   # render table of quartiles and mean from bpms, residues, errors.
   output$quantileLow <- renderTable(align = "lcccccc", width = "100%", {
      data <- calculate_quantile(filteredInputLow(), input$deviceSelect1, input$deviceSelect2)
      req(data)
      data
   })
   output$quantileMed <- renderTable(align = "lcccccc", width = "100%", {
      data <- calculate_quantile(filteredInputMed(), input$deviceSelect1, input$deviceSelect2)
      req(data)
      data
   })
   output$quantileHig <- renderTable(align = "lcccccc", width = "100%", {
      data <- calculate_quantile(filteredInputHig(), input$deviceSelect1, input$deviceSelect2)
      req(data)
      data
   })
   output$quantileSum <- renderTable(align = "lcccccc", width = "100%", {
      data <- calculate_quantile(filteredInputSummary(), input$deviceSelect1, input$deviceSelect2)
      req(data)
      data
   })
   
   # render plots with two lines
   output$plotLow <- renderPlotly({
      create_plot(filteredInputLow(), input$deviceSelect1, input$deviceSelect2)
   })
   output$plotMed <- renderPlotly({
      create_plot(filteredInputMed(), input$deviceSelect1, input$deviceSelect2)
   })
   output$plotHig <- renderPlotly({
      create_plot(filteredInputHig(), input$deviceSelect1, input$deviceSelect2)
   })
   
   # render plots with residues
   output$plotResiLow <- renderPlotly({
      create_resi_plot(filteredInputLow())
   })
   output$plotResiMed <- renderPlotly({
      create_resi_plot(filteredInputMed())
   })
   output$plotResiHig <- renderPlotly({
      create_resi_plot(filteredInputHig())
   })
   
   # render Bland&Altman plot
   output$BAPlotLow <- renderPlotly({
      create_bland_altman_plot(filteredInputLow())
   })
   output$BAPlotMed <- renderPlotly({
      create_bland_altman_plot(filteredInputMed())
   })
   output$BAPlotHig <- renderPlotly({
      create_bland_altman_plot(filteredInputHig())
   })
   
   # render box plot showing outliers
   output$boxPlotLow <- renderPlotly({
      create_box_plot(inputLowOutliers())
   })
   output$boxPlotMed <- renderPlotly({
      create_box_plot(inputMedOutliers())
   })
   output$boxPlotHig <- renderPlotly({
      create_box_plot(inputHigOutliers())
   })
   output$boxPlotWarning1 <- output$boxPlotWarning2 <- output$boxPlotWarning3 <- renderText({
      if (!is.null(input$otherOptions) && 'io' %in% input$otherOptions){
         "Box plot is independent on 'ignore outliers' option"
      } else {
         ""
      }
   })
   
   # render tables of input data
   output$tableLow <- renderTable(align = "cccc", width = "100%", {
      data <- create_table(filteredInputLow(), input$deviceSelect1, input$deviceSelect2)
      req(data)
      data
   })
   output$tableMed <- renderTable(align = "cccc", width = "100%", {
      data <- create_table(filteredInputMed(), input$deviceSelect1, input$deviceSelect2)
      req(data)
      data
   })
   output$tableHig <- renderTable(align = "cccc", width = "100%", {
      data <- create_table(filteredInputHig(), input$deviceSelect1, input$deviceSelect2)
      req(data)
      data
   })
}